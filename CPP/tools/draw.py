import numpy as np
import matplotlib.pyplot as plt
from matplotlib import colors
import os
import struct

# --- 参数设置 (与 C++ 代码一致) ---
N = 256
L = 50.0
DIM = 2
TOTAL_PARTICLES = N * N

def read_binary_data(filename):
    """
    读取由 C++ 程序生成的二进制数据文件。
    Reads the binary data file generated by the C++ program.
    """
    if not os.path.exists(filename):
        print(f"Error: Data file not found: {filename}")
        return None, None

    # 每个粒子有两个 double (x, y), 每个 Vec2D 是 16 bytes
    # Each particle has two doubles (x, y), so each Vec2D is 16 bytes.
    expected_size = TOTAL_PARTICLES * 2 * 16 # pos 和 mom
    
    file_size = os.path.getsize(filename)
    if file_size != expected_size:
        print(f"Warning: File size mismatch for {filename}. Expected {expected_size}, got {file_size}")
        return None, None
        
    with open(filename, 'rb') as f:
        # 读取位置数据 (Read position data)
        pos_bytes = f.read(TOTAL_PARTICLES * 16)
        positions = np.frombuffer(pos_bytes, dtype=np.float64).reshape((TOTAL_PARTICLES, DIM))
        
        # 读取动量数据 (Read momentum data)
        mom_bytes = f.read(TOTAL_PARTICLES * 16)
        momenta = np.frombuffer(mom_bytes, dtype=np.float64).reshape((TOTAL_PARTICLES, DIM))

    return positions, momenta

def plot_density_for_time(shape, L_box, time, bbox, ax):
    """
    加载数据并为指定时间绘制密度图。
    Loads data and plots the density map for a specific time.
    """
    filename = f'../build/data/x.{int(round(time*1000)):05d}.bin'
    x_pos, _ = read_binary_data(filename)

    if x_pos is None:
        ax.text(0.5, 0.5, f"Data not found for a={time}", ha='center', va='center', color='white', transform=ax.transAxes)
        ax.set_facecolor('black')
        return None

    # 创建一个用于绘图的网格，可以比模拟网格更精细以获得更平滑的图像
    # Create a grid for plotting, which can be finer than the simulation grid
    plot_shape = (shape[0] * 2, shape[1] * 2)
    density_grid = np.zeros(plot_shape, dtype=np.float32)
    
    # 将粒子位置从物理单位转换为网格单位
    # Convert particle positions from physical units to grid units
    res = L_box / plot_shape[0]
    x_grid = x_pos / res

    # 使用 Numba 加速的 CIC (CIC accelerated with Numba)
    # 提取原始 Python 代码中的 CIC 函数
    try:
        from numba import jit
        @jit(nopython=True)
        def md_cic_2d_numba(shape_x, shape_y, pos, tgt):
            for i in range(len(pos)):
                idx0, idx1 = int(np.floor(pos[i,0])), int(np.floor(pos[i,1]))
                f0, f1   = pos[i,0] - idx0, pos[i,1] - idx1
                
                # Periodic boundary
                i0, i1 = idx0 % shape_x, (idx0 + 1) % shape_x
                j0, j1 = idx1 % shape_y, (idx1 + 1) % shape_y

                tgt[i0, j0] += (1 - f0) * (1 - f1)
                tgt[i1, j0] += f0 * (1 - f1)
                tgt[i0, j1] += (1 - f0) * f1
                tgt[i1, j1] += f0 * f1
        md_cic_2d_numba(plot_shape[0], plot_shape[1], x_grid, density_grid)
    except ImportError:
        print("Numba not found, using pure Python for CIC (slower). Install with 'pip install numba'")
        # Pure python fallback
        for i in range(len(x_grid)):
            idx0, idx1 = int(np.floor(x_grid[i,0])), int(np.floor(x_grid[i,1]))
            f0, f1   = x_grid[i,0] - idx0, x_grid[i,1] - idx1
            i0, i1 = idx0 % plot_shape[0], (idx0 + 1) % plot_shape[0]
            j0, j1 = idx1 % plot_shape[1], (idx1 + 1) % plot_shape[1]
            density_grid[i0, j0] += (1 - f0) * (1 - f1)
            density_grid[i1, j0] += f0 * (1 - f1)
            density_grid[i0, j1] += (1 - f0) * f1
            density_grid[i1, j1] += f0 * f1
            
    # 使用 imshow 绘制密度场
    # Use imshow to plot the density field
    im = ax.imshow(density_grid.T, origin='lower', cmap='viridis',
                   extent=[0, L_box, 0, L_box],
                   norm=colors.LogNorm(vmin=0.1, vmax=density_grid.max() or 1))

    ax.set_xlim(*bbox[0])
    ax.set_ylim(*bbox[1])
    ax.set_aspect('equal')
    ax.set_facecolor('black')
    return im

def create_final_density_plot():
    """
    创建并保存最终的拼合密度图。
    Creates and saves the final composite density plot.
    """
    plt.rcParams["font.family"] = "serif"
    shape = (N, N)

    fig, axs = plt.subplots(2, 3, figsize=(15, 10), facecolor='white', constrained_layout=True)
    fig.suptitle('N-Body Simulation Density Evolution (C++ Backend)', fontsize=16)

    plot_times = [0.5, 1.0, 2.0]

    # 全局视图 (Full view)
    bbox_full = [(0, L), (0, L)]
    for i, t in enumerate(plot_times):
        print(f"Plotting full density view for a = {t}...")
        plot_density_for_time(shape, L, t, bbox=bbox_full, ax=axs[0, i])
        axs[0, i].set_title(f"a = {t}")

    # 缩放视图 (Zoomed view)
    bbox_zoom = [(15, 30), (5, 20)]
    for i, t in enumerate(plot_times):
        print(f"Plotting zoomed density view for a = {t}...")
        plot_density_for_time(shape, L, t, bbox=bbox_zoom, ax=axs[1, i])
        axs[1, i].set_title(f"Zoomed in, a = {t}")

    for ax in axs.flat:
        ax.set_xticklabels([])
        ax.set_yticklabels([])
        ax.set_xticks([])
        ax.set_yticks([])

    output_filename = 'nbody_density_plot_cpp.png'
    fig.savefig(output_filename, dpi=150, bbox_inches='tight')
    print(f"Final density plot saved as {output_filename}")

if __name__ == "__main__":
    if not os.path.exists('../build/data'):
        print("Error: 'data' directory not found.")
        print("Please run the C++ simulation first to generate data.")
    else:
        create_final_density_plot()

